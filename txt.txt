const gameData = [
      {
        id: 1,
        name: "Game A",
        gameType: "Singleplayer",
        numberOfPlayers: 1,
      },
      {
        id: 2,
        name: "Game B",
        gameType: "Multiplayer",
        numberOfPlayers: 4,
      },
      {
        id: 3,
        name: "Game C",
        gameType: "Singleplayer",
        numberOfPlayers: 2,
      },
    ];

  return (
    <section className="my-12">
      <div className="w-11/12 mx-auto">
        <h2 className="text-3xl p-3">Explore</h2>
      </div>
      <main className="w-11/12 mx-auto grid grid-cols-1">
        <div>
          <div className="mt-4">
            <h3 className="p-3 px-5 text-xl">View invitations</h3>
          </div>

          <div className="overflow-x-auto">
            <table className="min-w-full bg-white">
              <thead>
                <tr className="border-b">
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Name
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Game Type
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Participants
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody>
                {gameData.map((game) => (
                  <tr key={game.id} className="border-b">
                    <td className="px-6 py-4 whitespace-nowrap text-blue-500">
                      {game.name}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      {game.gameType}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      {game.numberOfPlayers}
                    </td>
                    <td className="px-3 py-4 whitespace-nowrap">
                      <button
                        className="text-green-500 text-white font-bold py-2 px-3 rounded mr-2"
                        title="Accept"
                      >
                        <AiOutlineCheckCircle className="text-2xl" />
                      </button>
                      <button
                        className="text-red-500 text-white font-bold py-2 px-3 rounded"
                        title="Reject"
                      >
                        <AiOutlineCloseCircle className="text-2xl" />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </main>
    </section>
  );

// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract PlayToEarn is Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;

    Counters.Counter private _gameCounter;
    Counters.Counter private _playerCounter;
    Counters.Counter private _participantCounter;

    struct GameStruct {
        uint id;
        string caption;
        address owner;
        uint participants;
        uint deadline;
        uint timestamp;
        bool isSingleGame;
        bool deleted;
    }

    struct PlayerStruct {
        uint id;
        uint gameId;
        address player;
    }

    struct Invitation {
        address invitedPlayer;
        bool accepted;
    }

    // Platform related data
    mapping(uint => GameStruct) private games;
    mapping(uint => PlayerStruct) private players;
    mapping(address => uint[]) private playerInvitations;

    // Check for existence of platform resources
    mapping(uint => bool) private gameExists;
    mapping(address => bool) private playerExists;
    mapping(uint => Invitation[]) private gameInvitations;
    mapping(uint => bool) private gameHasPlayers;

    // Modifiers
    modifier onlyGameOwner(uint gameId) {
        require(gameExists[gameId], "Game does not exist");
        require(games[gameId].owner == msg.sender, "Only the owner can invite players");
        _;
    }

    // Game functions
    function createGame(
        string memory caption,
        uint participants,
        uint deadline
    ) public onlyOwner {
        require(participants > 0, "Number of participants should be greater than zero");
        require(bytes(caption).length > 0, "Caption is required!");
        require(deadline > block.timestamp, "Deadline should be in the future");

        _gameCounter.increment();

        games[_gameCounter.current()] = GameStruct({
            id: _gameCounter.current(),
            caption: caption,
            owner: msg.sender,
            participants: participants,
            deadline: deadline,
            timestamp: block.timestamp,
            isSingleGame: participants > 2,
            deleted: false
        });
    }

    function invitePlayer(uint gameId, address player) public onlyGameOwner(gameId) {
        require(playerExists[player], "Player is not part of the game");
        require(!gameHasPlayers[gameId], "Game has already started");
        require(!isPlayerJoined(gameId, player), "Player is already part of the game");

        Invitation[] storage invitations = gameInvitations[gameId];
        require(invitations.length < games[gameId].participants, "Participant limit reached");

        invitations.push(Invitation({
            invitedPlayer: player,
            accepted: false
        }));
        playerInvitations[player].push(gameId);
    }

    function acceptInvitation(uint gameId) public {
        require(playerExists[msg.sender], "Player is not part of the game");
        require(gameExists[gameId], "Game does not exist");
        require(!isPlayerJoined(gameId, msg.sender), "Player is already part of the game");

        Invitation[] storage invitations = gameInvitations[gameId];
        for (uint256 i = 0; i < invitations.length; i++) {
            if (invitations[i].invitedPlayer == msg.sender && !invitations[i].accepted) {
                invitations[i].accepted = true;
                participants[players[_playerCounter.current()].id].isAvailable = false;
                joinGame(gameId);
                return;
            }
        }
        revert("Invitation not found");
    }

    function rejectInvitation(uint gameId) public {
        require(playerExists[msg.sender], "Player is not part of the game");
        require(gameExists[gameId], "Game does not exist");

        Invitation[] storage invitations = gameInvitations[gameId];
        for (uint256 i = 0; i < invitations.length; i++) {
            if (invitations[i].invitedPlayer == msg.sender && !invitations[i].accepted) {
                delete invitations[i];
                return;
            }
        }
        revert("Invitation not found");
    }

    function getPlayerInvitations() public view returns (uint[] memory) {
        return playerInvitations[msg.sender];
    }

    function joinGame(uint gameId) internal {
        gameHasPlayers[gameId] = true;
        _playerCounter.increment();
        players[_playerCounter.current()] = PlayerStruct({
            id: _playerCounter.current(),
            gameId: gameId,
            player: msg.sender
        });
    }

    // Volunteer functions
    function participate() public {
        require(!playerExists[msg.sender], "Participant already exists");

        _participantCounter.increment();
        playerExists[msg.sender] = true;
    }

    // Private functions
    function isPlayerJoined(uint gameId, address player) private view returns (bool) {
        Invitation[] memory invitations = gameInvitations[gameId];
        for (uint256 i = 0; i < invitations.length; i++) {
            if (invitations[i].invitedPlayer == player && invitations[i].accepted) {
                return true;
            }
        }
        return false;
    }

    function _currentTime() internal view returns (uint256) {
        return block.timestamp;
    }

    function _payTo(address to, uint256 amount) internal {
        (bool success, ) = payable(to).call{value: amount}("");
        require(success, "Payment failed");
    }
}


// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract PlayToEarn is Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;

    Counters.Counter private _gameCounter;
    Counters.Counter private _playerCounter;
    Counters.Counter private _participantCounter;

    struct GameStruct {
        uint id;
        string caption;
        address owner;
        uint participants;
        uint stake;
        uint deadline;
        uint timestamp;
        bool isSingleGame;
        bool deleted;
        bool paidOut;
        mapping(address => bool) readyPlayers; // New mapping to track player's readiness
    }

    struct PlayerStruct {
        uint id;
        uint participantId;
        uint gameId;
        address player;
        bool finished;
        bool ready;
    }

    struct ParticipantStruct {
        uint id;
        address participant;
        bool isAvailable;
    }

    struct InvitationStruct {
        address invitedPlayer;
        bool accepted;
    }

    uint private totalBalance;
    uint serviceFee = 0.5 ether;

    // for saving platform related data
    mapping(uint => GameStruct) game;
    mapping(uint => PlayerStruct) player;
    mapping(uint => ParticipantStruct) participant;
    mapping(uint => uint) gameInvitations;
    mapping(address => mapping(uint => InvitationStruct)) invitationsOf;

    // check for existence of platform resources
    mapping(uint => bool) gameExists;
    mapping(uint => bool) playerExists;
    mapping(uint => bool) participantExists;
    mapping(uint => mapping(address => bool)) invitationExists;

    mapping(uint => bool) gameHasPlayers;

    // Game functions

    function createGame(
        string memory caption,
        uint participants,
        uint deadline
    ) public payable {
        require(msg.value > 0 ether, "stake funds is required");
        require(!_availableParticipants(participants), "Available participants not enough");
        require(bytes(caption).length > 0, "Caption is required!");
        require(deadline > 0, "Duration should be greater than zero!");

        _gameCounter.increment();
        _saveGame(
            _gameCounter.current(),
            caption,
            msg.sender,
            participants,
            msg.value,
            deadline
        );
        // Make the creator of the game a participant in that game
        _participantCounter.increment();
        _saveParticipant(_participantCounter.current(), msg.sender, true);

        totalBalance += msg.value;
    }

    function getGames() public view returns (GameStruct[] memory) {
        uint activeGameCount = 0;
        uint256 currentTime = _currentTime();

        // Count the number of active games
        for (uint256 i = 1; i <= _gameCounter.current(); i++) {
            if (!game[i].deleted && game[i].deadline > currentTime) {
                activeGameCount++;
            }
        }

        // Create an array to store active games
        GameStruct[] memory activeGames = new GameStruct[](activeGameCount);
        uint activeIndex = 0;

        // Populate the activeGames array with active games
        for (uint256 i = 1; i <= _gameCounter.current(); i++) {
            if (!game[i].deleted && game[i].deadline > currentTime) {
                activeGames[activeIndex] = game[i];
                activeIndex++;
            }
        }

        return activeGames;
    }

    function getGame(uint id) public view returns (GameStruct memory) {
        return game[id];
    }

    // participate functions

    function participate() public {
        require(participantExists[_participantCounter.current()], "Participant already exists");

        _participantCounter.increment();
        _saveParticipant(_participantCounter.current(), msg.sender, true);
    }

    // invitation functions
    function invitePlayer(address invitedPlayer, uint gameId) public {
        require(participantExists[_participantCounter.current()], "Participant already exists");
        require(gameExists[gameId], "Game does not exist");
        require(!_isInvited(gameId, invitedPlayer), "Player is already invited to this game");

        // Store the invitation
        gameInvitations[gameId]++;
        _saveInvitation(gameId, invitedPlayer, false);
    }

    function acceptInvitation(uint gameId, uint participantId) public payable {
        require(msg.value >= game[gameId].stake, "Insufficient funds for stakes");
        require(gameExists[gameId], "Game does not exist");
        require(invitationsOf[msg.sender][gameId].invitedPlayer == msg.sender, "You are not invited to this game");
        require(!invitationsOf[msg.sender][gameId].accepted, "Invitation is already accepted");
        require(participant[participantId].isAvailable, "Participant is not available");

        _playerCounter.increment();
        _savePlayer(_playerCounter.current(), gameId, participantId, msg.sender, false, true);
        game[gameId].readyPlayers[msg.sender] = true; // Mark player as ready

        participant[participantId].isAvailable = false;
        participantExists[participantId] = true;

        totalBalance += msg.value;
    }

    function rejectInvitation(uint gameId) public {
        require(gameExists[gameId], "Game does not exist");
        require(invitationsOf[msg.sender][gameId].invitedPlayer == msg.sender, "You are not invited to this game");
        require(!invitationsOf[msg.sender][gameId].accepted, "Invitation is already accepted");

        delete invitationsOf[msg.sender][gameId];

        // Decrement the game invitations count
        if (gameInvitations[gameId] > 0) {
            gameInvitations[gameId]--;
        }
    }

    function getInvitations(address user) public view returns (InvitationStruct[] memory) {
        InvitationStruct[] memory userInvitations;
        uint totalInvitations = 0;

        for (uint i = 1; i <= _gameCounter.current(); i++) {
            if (gameExists[i] && invitationsOf[user][i].invitedPlayer != address(0)) {
                totalInvitations++;
            }
        }

        userInvitations = new InvitationStruct[](totalInvitations);
        uint currentIndex = 0;

        for (uint i = 1; i <= _gameCounter.current(); i++) {
            if (gameExists[i] && invitationsOf[user][i].invitedPlayer != address(0)) {
                userInvitations[currentIndex] = invitationsOf[user][i];
                currentIndex++;
            }
        }

        return userInvitations;
    }

    // Function to check if all players in a game are ready
    function allPlayersReady(uint gameId) public view returns (bool) {
        for (uint i = 1; i <= _playerCounter.current(); i++) {
            if (player[i].gameId == gameId && !game[gameId].readyPlayers[player[i].player]) {
                return false;
            }
        }
        return true;
    }

    // Function to distribute winnings after the deadline and deduct the service fee
    function distributeWinnings(uint gameId) public onlyOwner {
        require(gameExists[gameId], "Game does not exist");
        require(game[gameId].deadline <= _currentTime(), "Game deadline not reached yet");
        require(!game[gameId].paidOut, "Winning already distributed for this game");

        uint totalPlayers = 0;
        uint winnersCount = 0;
        for (uint i = 1; i <= _playerCounter.current(); i++) {
            if (player[i].gameId == gameId) {
                totalPlayers++;
                if (player[i].finished) {
                    winnersCount++;
                }
            }
        }

        require(winnersCount > 0, "No winners in this game");

        uint prizePerWinner = (game[gameId].stake * totalPlayers - serviceFee) / winnersCount;
        address winnerAddress;

        for (uint i = 1; i <= _playerCounter.current(); i++) {
            if (player[i].gameId == gameId && player[i].finished) {
                winnerAddress = player[i].player;
                _payTo(winnerAddress, prizePerWinner);
            }
        }

        // Deduct service fee and pay to contract owner
        totalBalance -= serviceFee;
        _payTo(owner(), serviceFee);

        game[gameId].paidOut = true;
    }
}


// Function to save a game
function _saveGame(
    uint id,
    string memory caption,
    address owner,
    uint participants,
    uint stake,
    uint deadline
) private {
    game[id] = GameStruct({
        id: id,
        caption: caption,
        owner: owner,
        participants: participants,
        stake: stake,
        deadline: deadline,
        timestamp: _currentTime(),
        isSingleGame: participants == 2,
        deleted: false,
        paidOut: false
    });
    gameExists[id] = true;
}

// Function to save a participant
function _saveParticipant(
    uint id,
    address participant,
    bool isAvailable
) private {
    participant[id] = ParticipantStruct({
        id: id,
        participant: participant,
        isAvailable: isAvailable
    });
    participantExists[id] = true;
}

// Function to save an invitation
function _saveInvitation(
    uint gameId,
    address invitedPlayer,
    bool accepted
) private {
    invitationsOf[invitedPlayer][gameId] = InvitationStruct({
        invitedPlayer: invitedPlayer,
        accepted: accepted
    });
    gameInvitations[gameId]++;
    invitationExists[gameId][invitedPlayer] = true;
}

// Function to save a player
function _savePlayer(
    uint id,
    uint gameId,
    uint participantId,
    address player,
    bool finished,
    bool ready
) private {
    player[id] = PlayerStruct({
        id: id,
        gameId: gameId,
        participantId: participantId,
        player: player,
        finished: finished,
        ready: ready
    });
    playerExists[id] = true;
}

// Function to check if enough available participants
function _availableParticipants(uint _participants) private view returns (bool) {
    uint256 availableCount = 0;
    for (uint256 i = 1; i <= _participantCounter.current(); i++) {
        if (participant[i].isAvailable) {
            availableCount++;
        }
    }
    return availableCount >= _participants;
}

// Function to check if a player is invited to a game
function _isInvited(uint gameId, address _player) private view returns (bool) {
    return invitationsOf[_player][gameId].invitedPlayer == _player && !invitationsOf[_player][gameId].accepted;
}

// Function to get the current timestamp
function _currentTime() internal view returns (uint256) {
    return block.timestamp;
}

// Function to transfer funds to an address
function _payTo(address to, uint256 amount) internal {
    (bool success, ) = payable(to).call{ value: amount }("");
    require(success, "Payment failed");
}
